section.without-page-numbers.without-header-footer
  // Cover page
  page
    .cover
      .logos
        .pull-left
          img.isima(src="isima.png")
          p.no-indent
            | ISIMA - Campus Universitaire des Cezeaux
            br
            | 1, Rue de la Chebarde
            br
            | TSA 60125, CS 60026
            br
            | 63178 Aubière CEDEX
        .pull-right
          img.cern(src="cern.jpg")
          p.no-indent
            | CERN
            br
            | Route de Meyrin 385
            br
            | Meyrin, Switzerland
        .clear
      .empty-line
      .empty-line
      .heading.center Engineer Report
      .heading.center 3rd Year Internship
      .title.center LHCb Performance and Regression Development
      .heading.center
        | Presented by: 
        span.bold Amine Ben hammou
      .empty-line
      .empty-line
      .col-1-of-2
        .heading
          | CERN Supervisor: 
          .bold Benjamin Couturier
        .heading
          | ISIMA Supervisor: 
          .bold MESNARD Emmanuel
      .col-1-of-2
        .heading
          | Internship duration: 
          .bold 5 months
        .heading
          | Date of presentation: 
          .bold August 28th 2015
      .clear

section.roman-page-numbers.without-header-footer
  // Acknowledgments
  page
    h1.no-number Acknowledgments
    p 
  // Figures Table
  page
    h1.no-number Figures Table
    figures-table

  // Abstract
  page
    h1.no-number Abstract
  
  // Contents Table
  page
    h1.no-number Contents Table
    contents-table(start="0", end="25")
  page
    .empty-line
    contents-table(start="26", end="51")
  page
    .empty-line
    contents-table(start="52")

  // Abbreviations Table
  page
    h1.no-number Abbreviations Table
    abbreviations-table

section.without-header
  // Introduction
  page
    h1.no-number Introduction
    p.
      As part of my third year at #[abbr ISIMA : Institut Supérieur d’Informatique, de Modélisation et de leurs Applications], I did my final internship at #[abbr CERN : The European Organization for Nuclear Research]. More specifically, I worked on the #[abbr LHCb : Large Hadron Collider beauty] experiment and participated on the development of LHCb Performance and Regression framework (LHCb PR).
    p The goal of the #[abbr LHCb PR : LHCb Performance and Regression] project is to provide developers with a profiling framework helping them to evaluate their recent changes by running analysis modules and comparing results. The results can be used to detect fails in functionalities or performance issues.
    p During my internship, I worked on the development of the new version of LHCbPR. My tasks were to upgrade the web application using AngularJs framework and the development of analysis modules for the new version. This version should provide the same functionalities as the old one and improve the user interface. The application should also give developers the ability to add new modules easily and without having to change the code of the core application.
    p This report presents the different task I have done during my five months internship and the results I obtained. After presenting CERN and LHCb experiment, I will explain the idea of the LCHbPR project and describe the old version of its web application. Then I will present the different parts of the new version. After this I will explain in details how the new frontend web application was made. Finaly I will present the analysis modules made in the new version.
  page
    h1 Presentation of CERN and LHCb
    h2 Presentation of CERN
    p CERN is the European Organization for Nuclear Research. Physicists and engenieers are working in this organization to discover how the universe works by studying the basic constituents of matter - the fundamental particles. Particles are made to collide together using the largest machine in the world to see how they interact and try to figure out the fundamental laws of nature. It was founded in 1954, and it sits astride the Franco-Swiss border near Geneva. It was one of Europe's first joint ventures and now has 21 member states.
    p Before they collide, the speed of particles is increased to close the speed of light using a sequence of accelerators. The largest accelerator is called the Large Hadron Collider (#[abbr LHC : Large Hadron Collider]) which is a ring with a perimeter of 27km. Detectors are used in the locations of collisions to observe and record the results.
    p There are seven experiments running on the LHC. The biggest four are: ATLAS, #[abbr CMS :  Compact Muon Solenoid] (Compact Muon Solenoid), #[abbr ALICE :  Compact Muon Solenoid] (A Large Ion Collider Experiment) and LHCb (Large Hadron Collider beauty). ATLAS and CMS are general-purpose experiments investigating the largest range of physics possible. ALICE and LHCb have detectors specialized for focussing on specific phenomena.
    h2 Presentation of LHCb
    p The LHCb experiment is one of seven particle physics detector experiments collecting data at the LHC. This experiment is trying to answer the question: "Why our universe is composed almost entirely of matter, but no antimatter ?".
    p Antimatter is made of anti-particules. An anti-particule of a particle p is a particle having exactly the opposite properties of p. When p and its anti-particule fusion, they cancel each other and produce pure energy. We think that just before the big bang, all the energy of the universe was compressed in one small point. So, at the moment of the big bang, this energy should have given the same quantity of matter and antimatter. The question is why do we observe only matter in our current universe ?
    p When the LHCb experiment is running, the detector registers about 10 million collisions per second. It is impossible to record all of these collisions.So the solution was to use an electronic system that will select the best and the most interesting collisions to be recorded. The recorded events are stored in binary files into disks. Then Physics are using specifique softwares to extract and study data on these files.

  page
    h1 The LHCbPR project
    h2 What is LHCbPR
    p LHCb Performance and Regression (LHCbPR) is a service designed to record important measurements about results of integration and performance tests of the LHCb applications. These applications receive input in the form of configuration files and produce, as an output, various information. LHCbPR is not intended to actually run the jobs, but instead to manage and track the job results. The LHCbPR is a framework that allows LHCb software developer to push information for a run of their code(job charactetistics, results, performance measures, files) to a central database. The main goal is to give developers the ability to perform analysis of the data across versions, running options and plateforms.
    h2 Why LHCbPR
    p In the past, the users had to run test jobs manually using a configuration file. A job could be run for a specific application and results should be saved by the user. These results was shared between users using static documents such as HTML, CSV or e-mail.
    p LHCbPR was conceived as a tool to reliably organize the process of configuring and monitoring a test job execution. The framework, solves the problem of gathering the results. It provides a complete script that can produce the desired output, according to a configuration file. This script uses a list of handlers that collect the defined aspects of the job results and push them to the database. By collecting the results in such an organized manner, it provides the solution to the second problem, mentioned above; the running of the analysis.
    p Since, all the data are stored in the database, the framework provides an abstract and easy way to deploy algorithms and functions which perform analysis on the saved data.
    p Finally, LHCbPR handles the presentation of the collected data by providing a set of templates for the creation of web pages specific to each analysis and customized to the preferences of each user.
    h2 Users of LHCbPR
    p The LHCbPR users can be divided into three categories: Administrators, Application developers and End users.
    p The administrators group is responsible for the integrity of the collected data and the efficiency of the service. They maintain and support the system, making sure the application is functional and available to the end users.
    p Application developers are the users who actively design and develop modules for the framework, thus extending the functionality of the application.
    p Finally, the end users are the main body of the users of the service. They put the tools provided by the application developers to practical use and their job results are populating the database.
  page
    h2 The old LHCbPR application
    p As my task is to upgrade the LHCbPR web application. I first started by reviewing the old version.
    p The LHCbPR follows the architectural model of three tiered programming. #[abbr 3TP : Three Tiered Programming] provides a way to theoretically categorize the components of an application, providing abstract modularity. In essence the 3TP model is a client-server architecture which is composed of three layers. Namely, the presentation tier, the functional process logic tier and the data storage tier. These tiers communicate with one another in a strictly defined way, which allows the developer to independently maintain each tier. In most practical applications of the model the presentation layer includes all forms of user interaction with the service. The process logic tier encompasses the whole of the application functionality, while the data storage tier handles the flow of the information from and to the data source (in most cases a database). 
    p The Django framework was used to create the LHCbPR web application and the 3TP model was applied as follows:
    p.no-indent
      span.bold Presentation Layer: 
      | A set of web pages using the jQuery library.
    p.no-indent
      span.bold Application Logic Layer: 
      | A set of python modules made using the Django framework.
    p.no-indent
      span.bold Data Storage Layer: 
      | An Oracle database storing all the applications and jobs informations and results.

    h1 New LHCbPR application
    p Instead of trying to improve the old version of the LHCbPR application, we started the new version from scratch to be able to use the new technologies of web development which was not used in the old version like Gulp task runner and the AngularJS framework. This framework enables us to build a rich client application using REST protocol for data access.
    h2 Architecture
    p The new version follows the 3TP model too, but in a more modern way. In particular, the presentation layer and the application logic layer are no longer in the same application. They are now two totaly separated applications communicating using a REST API. ...
    h2 Data Storage Layer: Database
    p We kept the same database as the old version but made some little changes to it. The new database entity relation schema is presented on figure in the next page. The main entities are the following:
    ul
      li
        span.bold Application: 
        | represents a software used by LHCb to process or analyse data. it is described by a name and has many versions
  page
    +image('ers.png', 'Database Entity Relation Schema')
    ul
      li
        span.bold Application Version: 
        | a version belongs to an application. It can be a release or a nightly build (intermediate version compiled every night).
      li
        span.bold Job Description: 
        | This entity describes all that is needed to define a job. In particular, it specifies the application version, the project setup, the running option, the plateforms in which jobs will be executed and the handlers that will collect results.
      li
        span.bold Handler: 
        | a handler has a name and a description. It gethers data after the job has been run. It is linked to multiple job descriptions via the "job handler" pivot table. It is also linked to many jobs via the "handler result" pivot table.
  page
    ul
      li
        span.bold Option: 
        | describes the command-line options to pass when running the jobs. I has a many to many relation with the attribute entity.
      li
        span.bold Attribute: 
        | an attribute can belong to multiple attribute groups. It also has a many to many relation with the job entity via the jobresult. Job results can have different types (integer, float, file, string). 
      li
        span.bold Job: 
        | This is the main entity that describes a job that has been run. It has a start time, an end time, and a status. It belongs to a job description and is run in a specifique plateform and host. Their results can be collected by multiple handlers and it can have multiple results. Every job result concerns an attribute.
    h2 Application Logic Layer: REST API
    p This layer is made using the #[span.bold Django REST framework] which is a powerful and flexible toolkit that makes it easy to build Web APIs using Python language. Making the application logic layer as an API is the best choice to keep layers totaly independent. This way we can build multiple frontend applications ( one for the web, an other for mobiles for example ) based on the same API.
    p #[abbr REST : Representational State Transfer] stands for #[span.bold Representational State Transfer]. (It is sometimes spelled "ReST") It relies on a stateless, client-server, cacheable communications protocol. In virtually all cases, the HTTP protocol is used. REST is an architecture style for designing networked applications.
    p In our case, the frontend application send requests to the API and the API responds with the requested data in #[abbr JSON : JavaScript Object Notation] (JavaScript Object Notation) format which is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript programming language which make it easy to parse it, as our frontend is written using JavaScript.
    h2 Frontend
    p The frontend application is made using the AngularJS javascript framework which add many features to #[abbr HTML : HyperText Markup Language] to make a new generation of web applications (single-page web applications). Instead of starting the web application from scratch, we have used a template called #[span.bold Angle] which offers a collection of ready to use styles and tools based on AngularJs and many javascript libraries. A More detailled description of the Angle features can be found in the next section.

  page
    h1 Frontend Development
    h2 Tools
    p We have used the Angle template as a starting point for the development of the frontend application. This template includes AngularJS, jQuery and many other libraries. It offers also some useful predefined Angular directives and services. In order to understand the structure of this template and be able to customize it, a good understanding of AngularJS architecture and terms is essential. The most important tools used to build the frontend application are the following:
    h3 AngularJS
    .col-1-of-5
      img.responsive(src="angularjs.png")
    .col-4-of-5
      p.no-indent #[span.bold AngularJS] is an open-source web application framework maintained by Google and by a community of developers and corporations to address many of the challenges encountered when developing single-page applications. It aims to simplify both the development and the testing of such applications by providing a framework for client-side web application which is able to add new reusable features to HTML.
        br
        | Official Website: 
        a(href="https://angularjs.org/") https://angularjs.org
    .clear
    h3 jQuery
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="jquery.gif")
    .col-4-of-5
      p.no-indent The usage of AngularJS does not eliminate jQuery which is the most used javascript library in web applications today. It is designed to simplify document navigation, #[abbr DOM : Document Object Model] (Document Object Model) elements selection, animations, events handeling, and #[abbr Ajax :  Asynchronous JavaScript and XML] (Asynchronous JavaScript and XML) calls. jQuery also provides capabilities for developers to create plug-ins on top of the JavaScript library. This enables developers to create abstractions for low-level interaction and animation, advanced effects and high-level, theme-able widgets.
        br
        | Official Website: 
        a(href="https://jquery.com/") https://jquery.com
    .clear
    h3 Git
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="git.png")
    .col-4-of-5
      p.no-indent Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It helps to keep track of every change made on the code and rollback when needed. It is also the best way to work on group on the same project.
        br
        | Official Website: 
        a(href="https://git-scm.com") https://git-scm.com
    .clear

  page
    h3 npm
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="npm.png")
    .col-4-of-5
      p.no-indent #[abbr npm : Node Package Manager] is package manager for JavaScript, and is the default one for NodeJS packages. NodeJS gives the possibility to run the javascript on the server side making it possible to write javascript files and run them from the terminal. 
    .clear
    p After the release of NodeJS on 2009, developers started making reusable node modules and the #[span.bold node package manager] (npm) was created on 2011 to make it easy to share and reuse node modules. But now it is used to manage all types of javascript modules and packages.
      br
      | Official Website: 
      a(href="https://www.npmjs.com/") https://www.npmjs.com
    p npm is used in our application to manage packages such as Bower and Gulp.    
    h3 Bower
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="bower.png")
    .col-4-of-5
      p.no-indent Bower is a package manager for frontend components such as #[abbr CSS : Cascading Style Sheets] and javascript libraries. It is installed using npm as it is a node module. Bower does not replace npm. npm manages server side packages will bower manages frontend packages.
        br
        | Official Website: 
        a(href="https://www.bower.io/") https://www.bower.io
    .clear
    h3 Gulp
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="gulp.png")
    .col-4-of-5
      p.no-indent Gulp is a javascript task runner or build tool. It can run several tasks automatically to improve the developer workflow. Tasks are written in javascript and can do various jobs from concatenating multiple files into one to compiling a Less source code (the less language is presented below) and compressing the resulting CSS code and storing it in a destination file.
      p.no-indent Gulp uses Steams (the NodeJS objects representing a buffer of data) during the task operations. So there is no need to store intermediate results in temporary files. It also runs the tasks in parallel which is more efficient. Dependencies between tasks can be declared to force a task not to start before the end of an other one. Gulp can also watch files and run corresponding tasks when a file is changed.
        br
        | Official Website: 
        a(href="https://www.gulpjs.com/") https://www.gulpjs.com
    .clear
    h3 jade
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="jade.png")
    .col-4-of-5
      p.no-indent Jade is a templating language which produces HTML code from a less verbose syntax. The Jade syntax is more easy to write, read and maintain. More than that, the Jade language has many features which make the code dynamic and reusable.
        br
        | Official Website: 
        a(href="https://www.jade-lang.com/") https://www.jade-lang.com
    .clear

  page
    p.no-indent All the HTML files in our frontend application are written using Jade and compiled by Gulp.
    h3 less
    .col-1-of-5
      img.responsive.right-marged.top-marged(src="less.png")
    .col-4-of-5
      p.no-indent Less is a CSS pre-processor, meaning that it extends the CSS language, adding features that allow variables, mixins, functions and many other techniques that allow the developer to make CSS that is more maintainable, themable and extendable.
    .clear
      p.no-indent There are also many 3rd party tools that help to compile less files and watch for changes. Gulp is one of these tools.
        br
        | Official Website: 
        a(href="https://www.lesscss.org/") https://www.lesscss.org

    h2 Files structure
    p After modifications made to the initial template, the files structure of the application is the following:
    +code('bash', 'The files structure of the frontend application').
      app/               # the build folder
      master/            # the sources folder
          |-- bower_components/   # bower installed packages
          |-- jade/               # the core application views
          |-- js/                 # the core application js files
          |-- less/               # the core application styles
          |-- modules/            # modules folder
          |-- node_modules/       # NodeJs installed modules
          |-- bower.json          # bower manifest file
          |-- gulpfile.js         # Gulp tasks definition
          |-- package.json        # npm manifest file
          |-- vendor.base.json    # packages to load with the application
          |-- vendor.json         # packages that will be loaded when needed
      vendor/            # the libraries folder
      index.html

    p All the application source code is inside the master directory. Under this directory we find:
    ul
      li
        tag bower_components: 
        | When we install a package using Bower, it is stored into this directory. Then when Gulp is run, it takes all needed Javascript and CSS files from this directory, minify them (by removing all optional white spaces and renaming variables and functions with short names in order to reduce the file size) and store them into the libraries directory named #[tag vendor].
  page
    ul 
      li Gulp knows which files are needed from the vendor.base.json and vendor.json. vendor.base.json  lists the packages to be loaded with the core application (like Angular and jQuery). vendor.json lists other needed packages, which will be loaded specifically depending on the visited module.
      li
        tag jade: 
        | The core view files are stored into this directory. Views are written using the Jade language and compiled into HTML files by Gulp. The compiled HTML files are stored into the app/views directory.
      li
        tag js: 
        | This directory contains all the core javascript files of the application. Since AngularJS is used to build this application; we find controllers, directives and services directories inside the js one following the Angular conventions. Additional javascript classes are stored inside the js/classes folder. One of this classes is the Module class which will be used to create modules for the application.
      li
        tag less: 
        | This directory holds all application style definitions. They are written using a CSS pre-processor called Less. Gulp will compile all this files into CSS files and store them in app/css directory.
      li
        tag modules: 
        | This directory contains source code of modules. the module structure is detailed below.
      li
        tag node_modules: 
        | NodeJs modules installed using npm install will be stored into this directory.
      li
        tag gulpfile.js: 
        | This file contains the Gulp tasks definitions.

    h2 Tools installation
    ul 
      li 
        span.bold 1. Setup NodeJS and npm: 
        | installation instructions for different systems are described in this link: 
        a(href="https://nodejs.org/download") https://nodejs.org/download
        br
        | In my case, I am using Ubuntu 14.04 and the setup commands are:
        +code('bash', 'NodeJS and npm installation commands on Ubuntu', 4).
          # adding the NodeSource PPA
          curl --silent --location https://deb.nodesource.com/setup_0.12 | sudo bash - 
          # update packages list
          sudo apt-get update
          # installing NodeJS (npm is installed with it automatically)
          sudo apt-get install --yes nodejs
  page
    ul
      li 
        span.bold 2. Setup Git: 
        | Git can be installed on Ubuntu from the default package manager: 
        +code('bash', 'Git installation command on Ubuntu', 0.1).
          sudo apt-get install git
      li 
        span.bold 3. Setup Bower and Gulp: 
        | Bower and Gulp are installed using npm. We install them globally to be able to use their commands from any directory: 
        +code('bash', 'Bower and Gulp installation commands', 4).
          sudo npm install -g bower
          sudo npm install -g gulp
      li 
        span.bold 4. Setup the application dependencies: 
        | Inside the #[tag master] directory, running the following commands will install all the needed dependencies for the application to work. The list of dependencies is read from the file #[tag package.json] for npm and #[tag bower.json] for Bower. 
        +code('bash', 'Dependencies installation commands', 4).
          sudo npm install
          bower install
    h2 Building and running the application
    p The application source code is built using Gulp to produces HTML, CSS and javascript files and store them into the #[tag app] folder. Gulp also runs a local server into this folder so that the developer can see the resulting application in the browser. After the build process, Gulp watchs all sources files. When a source file is changed and saved, Gulp re-compile this file and refresh the application page on the browser. This way, the developer can change the source code and see the result immediately in the browser.
  page
    h3 The gulpfile
    p The file #[tag gulpfile.js] contains the declaration of Gulp tasks. Declaring a task in this file can be done as follows:
    +code('javascript', 'Gulp task declaration example').
      var gulp = require('gulp'); // requiring the gulp module
      gulp.task('copy', function(){
        gulp.src('folder1/*')
          .pipe(gulp.dest('folder2'));
      });
    p In the code above, we created a task called #[tag copy] to copy all files under the  #[tag folder1] into #[tag folder2]. To run this task from the command-line, we type:
    pre: code.language-bash gulp copy

    h3 Gulp tasks 
    p In our application, the main Gulp tasks are the following:
    ul
      li 
        .bold scripts:vendor
        | This task runs two sub tasks #[span.bold scripts:vendor:base] and #[span.bold scripts:vendor:app]. The first one minifies and concatenates all the base vendor files (read from #[tag master/vendor.base.json]) into the file #[tag app/js/base.js]. The second one reads the list of additional vendor files from #[tag master/vendor.json] and copies them into the folder #[tag vendor].
      li 
        .bold scripts:app 
        | This task minifies and concatenates all the core application javascript files into #[tag app/js/app.js].
      li 
        .bold styles:app, styles:themes and bootstrap
        | Those are stylings tasks. The #[span.bold bootstrap] task compiles the Less source code of the bootstrap library. The two other tasks compile the core application Less files. The resulting CSS files are stored into #[tag app/css].
      li 
        .bold templates:app, templates:views and templates:pages 
        | Those tasks compile the Jade source files of the index, views and pages respectively and store the resulting HTML files into #[tag app], #[tag app/views] and #[tag app/pages] respectively.
  page
    ul
      li 
        .bold modules:scripts 
        | This task concatenates all the javascript files of each module and stores them under #[tag app/modules/module_name/all.js]
      li 
        .bold modules:styles 
        | This task compiles the less file of each module and stores the result into #[tag app/modules/module_name/style.css]
      li 
        .bold modules:views 
        | This task compiles all jade files under the views directory of each module and stores the resulting HTML files into #[tag app/modules/module_name/views]
      li 
        .bold watch
        | This task watches all source files for changes and runs the corresponding task when a file is modified.
      li 
        .bold connect
        | This task runs a local webserver into the app directory to see the results in the browser.
      li 
        .bold start
        | This task compiles the application without vendors ( by running the other tasks ) and starts the server by running the #[tag connect] task.
      li 
        .bold default
        | This task compiles the application and vendors and starts the server by running the #[tag connect] task. This task is run automatically when we execute the command "gulp" in the master directory.
    
    h2 Basics of AngularJS
    p AngularJS is a very powerful framework for client-side applications. In this section, I will try to cover the minimum required basics in order to understand how the frontend application is built and be able to add new modules to it.
  page
    h3 Starting example
    p A very simple example of using AngularJS could be the following:
    +code('markup', 'Starter example of using AngularJS').
      &lt;!doctype html>
      &lt;html>
      &lt;head>
        &lt;meta charset="utf-8">
        &lt;title> Angular Sample &lt;/title>
      &lt;/head>
      &lt;body data-ng-app="demo">
        &lt;p> Your name : &lt;input type="text" ng-model="name">&lt;/p>
        &lt;p> Hello {{ name }} &lt;/p>

        &lt;script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js">
        &lt;/script>
        &lt;script>
          var app = angular.module('demo', []);
        &lt;/script>
      &lt;/body>
      &lt;/html>
    p In the code above, we included the AngularJS javascript file from Google and we defined a new angular module called "demo". Please note that we put the scripts at the end of the body element to speed up the page loading. The attribute #[tag data-ng-app] of the body element tells AngularJs which angular module to be applied to the page.
    p We defined a text input and set the attribute #[tag ng-model] to "name". This will define a variable called "name" and bind it's value with the content of the input. So if we type some text in this input, the value of the variable name will be set to this text. Finally we show the value of the variable name using the syntax #[tag(ng-non-bindable) {{name}} ]. This example shows the data binding feature of AngularJS, so by changing the value of the input, the text in the next paragraph is changed too.
    p In the following, you find short definitions and examples of the most important AngularJS terms.
  page
    h3 Angular Module
    p A module is a reusable collection of the application parts ( controllers, services, directives, ...). An application can use one or multiple modules. When declaring a module, we can specify the list of dependent module that this module will use. The parts of the related modules could be injected by AngularJS automatically and used.
    p: .bold Example
    +code('javascript', 'AngularJS module declaration example').
      // declaration of new angular module
      var app = angular.module('myApp', ['module1', 'module2']);
    p Here we declared a module called "myApp" which depends on "module1" and "module2".
    h3 Controller and Scope
    p A controller is a javascript function that handles a view or a part of the page. It can bind variables and events to this part of the page. The variables binded to a view are held into an object called the scope. This object can be injected automatically into the controller simply by adding #[tag $scope] to the function arguments.
    p: .bold Example
    +code('javascript', 'AngularJS Controller example').
      // using the app variable which is the module
      app.controller('HomeController', function($scope){
        // use the scope to define binded variables
        // A name variable for example
        $scope.name = 'LHCbPR';
        // or an array
        $scope.tools = ['AngularJS', 'Bower', 'Gulp'];
      });
    p The code above will not work after minification. A recommanded way is to declare dependencies into a list of strings and add them to the function arguments in the same order like this:
  page
    pre: code.language-javascript.
      app.controller('HomeController', ['$scope', function($scope) {
        // ...
      }]);
    p To use the controller in the view, we first declare it using #[tag ng-controller] then use the variables and methods of the scope inside this view like the following:
    +code('markup', 'Using Angular Controller in the view').
      &lt;div ng-controller="HomeController">
        &lt;p> The {{name}} web application is built using: &lt;/p>
        &lt;ul>
          &lt;li ng-repeat="element in tools"> {{ element }} &lt;/li>
        &lt;/ul>
      &lt;/div>
    p The attribute #[tag ng-repeat] we added to the #[tag &lt;li>] element is a predefined angular directive which loops over a array and repeat the element for each item of the array. The resulting view will be something like:
    +image('view-sample-1.png', 'Sample View')
  page
    h3 Directives
    p A directive is a new element or behavior added to the HTML. #[tag ng-controller] and #[tag ng-repeat] are examples of directives which are used as attributes. When defining a directive we specify wether it will be used as an element (an HTML tag), an attribute or a class. This choice depends on the feature added by the directive:
    ul
      li A directive which is replaced by a template or view is more likely to be used as an element. 
      li A directive which adds a behavior to HTML elements based on an input is more likely to be used as an attribute.
      li A directive which adds a generic decoration or behavior to HTML elements is more likely to be used as a class.
    p These rules remain subjective as AngularJS enables the developer to give multiple uses to the same directive ( a directive that can be used as an element and as an attribute for example).
    p For example, let us define a directive that takes a collection of objects and shows them as an HTML table. First we will define the template as follows (note that we are using some predefined CSS classes):
    +code('markup', 'Data table sample directive template').
      &lt;table class="table table-striped table-bordered">
        &lt;thead>
          &lt;tr>
            &lt;!-- We assume that the list of titles will be declared -->
            &lt;th ng-repeat="title in titles"> {{ title }} &lt;/th>
          &lt;/tr>
        &lt;/thead>
        &lt;tbody>
          &lt;!-- We assume that data is the collection of objects -->
          &lt;tr ng-repeat="item in data">
            &lt;td ng-repeat="title in titles"> {{ item[title] }} &lt;/td>
          &lt;/tr>
        &lt;/tbody>
      &lt;/table>
  page
    p Then we define the directive as follows:
    +code('javascript', 'Data table sample directive code').
      app.directive('myTable', function(){
        // The directive consists on an object that this function should return
        return {
          restrict: 'E', // define how the directive will be used
          // 'E' for element, 'A' for attribute and 'C' for class
          // 'EA' means element or attribute 
          templateUrl: 'data-table.html', // the template file
          // if specified, the content of the HTML element to which the directive
          // is applied will be overitten by this template
          scope: { // contains the data passed to the directive as attributes
            data: '='
          },
          // This function is executed when the directive is rendered
          link: function(scope){
            // scope.data will refer the data passed to the directive
            // Defining titles of the table as the properties of the first
            // object in data, as we assume all objects have the same properties
            scope.titles = [];
            if(scope.data != undefined && scope.data.length > 0){
              for(attr in scope.data[0]){
                scope.titles.push(attr);
              }
            }
          }
        };
      });
    p Now assuming that we have a collection of objects in the scope like this:
    pre: code.language-javascript.
      $scope.collection = [
        { Experiment: 'CMS', 'LHC experiment ?': 'Yes', Type: 'General' },
        { Experiment: 'ATLAS', 'LHC experiment ?': 'Yes', Type: 'General' },
        { Experiment: 'LHCb', 'LHC experiment ?': 'Yes', Type: 'Specific' },
        { Experiment: 'ALICE', 'LHC experiment ?': 'Yes', Type: 'Specific' }
      ];
  page
    p We can use the directive in the view (the HTML code) as follows:
    pre: code.language-markup.
      &lt;my-table data="collection">&lt;/my-table>
    p The result is a table of the given data:
    +image('my-table.png', 'Data table sample directive result')

    h3 Services
    p A service is an object which is instanciated once (Signleton) and injected into components using it (like controllers and directives). Service is a good way to share functionalities between different components of the application.
    p AngularJS provides several predefined services like #[tag $http] which handles AJAX requests. To use this service inside a controller for example, all we have to do is to add it to the arguments:
    +code('javascript', 'Example of injecting $http service').
      app.controller('MyController', ['$scope', '$http', function($scope, $http){
        // Now $http can be used here
      }]);
    p In our application, we are using a service called #[span.bold Restangular]. It is built on top of #[tag $http] and simplifies the communication with a REST API.

    h3 Routing
    p the routing functionality in AngularJS helps to create single-page web applications. The #[tag $routeProvider] contained in the #[tag ngRoute] module is used to configure routes of the application. A route definition consists on the definition of an URL pattern with the corresponding view and controller. Routes are configured using the #[tag config()] method as follows:
  page
    +code('javascript', 'Routes configuration example').
      // The module depends on the ngRoute module 
      // because we need to use $routeProvider
      var app = angular.module('demo', ['ngRoute']);
      // Routes configuration
      app.config(['$routeProvider', function($routeProvider) {
        $routeProvider
          .when('/home', {
            templateUrl: 'home.html',
            controller: 'HomeController'
            }
          })
          .when('/experiments/:name', {
            templateUrl: 'experiment.html',
            controller: 'ExperimentController'
            }
          })
          .otherwise('/home');
      }]);
    p Here we defined two routes. The first route for the home page. The second route for the experiment page. Note that the URL pattern of the second route contains a parameter called #[tag :name] which will be matched as an alpha-numeric string. A parameter in the URL pattern always starts with ":" and its value can be retrieved using the #[tag $routeParams] service. The default URL to apply when no pattern is matched is defined with the #[tag otherwise()] method. In the previous code, if no pattern is matched, the user will be redirected to the home page.
    p In addition to #[tag home.html] and #[tag experiment.html] mentioned in the route definitions, we need to create #[tag index.html] which is the single page to be loaded directly by the browser. Inside this page, we use the #[tag ng-view] directive to insert the view corresponding to the URL pattern.
    p Assuming that the link of our application is "http://demo.com/", when this link is visited, the browser will load the #[tag index.html] file and then load all javascript and CSS files referenced inside it. The browser will then run the javascript code. In particular, the routes will be defined and angular will match the URL and find the current route. The URL of the route is the part of link after the first "#" character. This character is used because the browser does not reload the page when the string after "#" is changed; which enables Angular to handle this part of the link and load views via AJAX. 
  page
    p When the link does not contain any "#", the route URL is supposed empty. In this case, Angular will redirect us to the home page by appending "#/home" to the link and loading #[tag home.html] inside the #[tag ng-view] directive. In the same way, visiting "http://demo.com/#/ experiment/LHCb" will load the #[tag experiment.html] and the value of the parameter name inside the #[tag ExperimentController] will be "LHCb".

    h2 Frontend core application features
    p Many AngularJS modules are used in our frontend application to provide module developers with useful functionalities. The most important functionalities and their use case are presented below.
    h3 States and Lazy loading
    p Our application contains many analysis modules. To map URLs to modules we are using #[span.bold states]. States are like routes with the ability to be nested. This way a module of the application is described by a state and can have sub states. The states feature is offered by #[span.bold AngularUI Router] which is an AngularJS module providing #[tag $state] service and #[tag $stateProvider] to handle states.
    p When declaring a state, in addition to the view and the controller, a list of dependencies can be provided. These dependencies will be loaded with the state. A dependency is a name referencing a collection of javascript and CSS files. The file #[tag vendor.json] contains the starting list of dependencies. The process of loading these files only when needed is called #[tag Lazy loading] which makes the application faster. The application analysis modules are added automatically to the list of dependencies so that one module can depend on an other.
    p The code to define states will be presented in the next section.
    h3 LHCbPR service
    p All analysis modules need to communicate with the REST API to retrieve data from the database and present it. The frontend application contains the #[tag lhcbprResources] service which extends the Restangular service and simplifies sending and requesting data from the REST webservice. Here is an example retreiving the list of active applications:
  page
    +code('javascript', 'Example of requesting data from the REST API').
      app.controller('TestController', [
      '$scope','lhcbprResources',function($scope,lhcbprResources) 
      {
          // Get the list of active applications
          lhcbprResources.all('active/applications')
              .getList()
              .then(function(response){
                  // Do what ever you want with the response
                  // This will show the list on the console
                  console.log(response);
              });

              // Some other code here
              // Please note that the AJAX calls are asynchronious 
              // which means that the code here maybe executed while 
              // waiting for the response
      }]);
    h3 Directives
    p The core application contains a collection of predefined directives that can be used in the analysis modules development. The most important directives are presented in the following.
    h4 DataTables
    p the #[tag ngTable] directive can be used to insert a table of data with sorting, filtering and pagination features. For example, to insert a table of jobs, we add the following code in the view (note that this is Jade source code; all analysis modules views are written using Jade which is less verbose then HTML):
  page
    +code('jade', 'Example of ngTable directive: the view code').
      table.table.table-striped.table-bordered.table-hover.be-responsive(
        ng-table="tableParams")
      thead: tr
        th ID
        th Name
      tbody
        tr(ng-repeat="attr in $data")
          td {{attr.id}}
          td {{attr.name}}
    p Then we add the following code in the controller:
    +code('javascript', 'Example of ngTable directive: the controller code').
      App.controller('TestController', [
        '$scope', 'ngTableParams', function($scope, ngTableParams) 
      {
        // We define some hard coded data
        $scope.attrs = [
          { id: 5, name: "EVENT_LOOP" },
          { id: 6, name: "EVENT_LOOP_count" },
          { id: 7, name: "EVENT_LOOP_rank" }
        ];

        // Table parameters
        $scope.tableParams = new ngTableParams(
          { page: 1, count: 10 }, 
          { total: 0, getData: function($defer, params) {
              // We just show the hard coded values
              $defer.resolve($scope.attrs);
          }});

        // Add this line to fix a bug in the ng-table directive
        $scope.tableParams.settings().$scope = $scope;
      }]);
  page
    p The result is something like this:
    +image('jobs-data-table.png', 'Example of Data Table')

    h4 Charts
    p Many charts directives are included and can be used in the analysis modules. These chart directives are based on five javascript libraries. The library that was used in developing charts on the analysis modules is #[span.bold ChartJS] which is flexible and provides many types of charts. Exemples of charts provided by this library are the following:
    +image('charts-samples.png', 'Examples of predefined chart directives')
  page
    h4 Search Jobs
    p This is the most used directive in analysis modules. It shows a form in which the user can filter jobs by application, options and versions. And notifies the controller each time the selection changes.
    p To insert the directive in the view, we use the Jade code below:
    +code('jade', 'Example of using search-jobs directive: the view code').
      search-jobs(on-found="updateJobs(searchParams)")

    p And then we define the callback function in the controller as follows:
    +code('javascript', 'Example of using search-jobs directive: the controller code').
      $scope.updateJobs = function(params){
          // You can use the selected parameters:
          // params.apps[0]: the selected application id
          // params.options: array of selected options ids
          // params.versions: array of selected versions ids
      };
    p This directive binds selected parameters to the URL on every change which means that visiting the generated URL will selected these parameters automatically.

  page
    h1 Application Modules Development
    p The frontend interface contains three main parts:
    ul
      li A header containing the logo and loading icon displayed when data is being loaded from the API.
      li A sidebar containing the list of analysis modules.
      li A content area showing the selected module.
    h2 Files structure
    p All modules are stored under the #[tag master/modules] directory. Each module have the following files structure:
    +code('bash', 'Module files structure').
      module_name/
          |-- js/               # the javascript files
          |   |-- controllers/  # controllers
          |   |-- directives/   # custom directives
          |   |-- init.js       # initialization file
          |-- less/
          |     |-- style.less  # custom styles
          |-- views/            # views
    ul
      li
        tag js/init.js 
        | contains the definition of the module. Here we describe what are the states of module and what are links to add on the sidebar.
      li
        tag js/controllers/
        | This directory contains the controllers of the module. Each controller is written on it's own javascript file.
      li
        tag js/directives/
        | This directory contains additional directives defined for this analysis module. This directory is optional. Other directories like services or filters could be added to contain custom components used within the module.
      li 
        tag less/style.less
        | This file contains custom styles code for the module elements.
      li 
        tag views/ 
        | This directory contains the views of the module. Each view is defined by a Jade file.
  page
    h2 Helper classes
    p In order to make the modules development process more simple. I added some helper classes to hide a part of the Angular complexity.
    h3 Module class
    p The module class simplifies the declaration of new modules. It offers the following methods:
    
    p.bold Module.create(name, title, position, settings)
    ul 
      li
        tag name 
        | The name of the module, it should be unique for each module.
      li
        tag title 
        | The title of the module menu in the sidebar.
      li
        tag position 
        | The position of the module menu in the sidebar. If two modules have the same position, there are shown one under the other.
      li
        tag settings 
        | An optional plain object specifying the folder name of the module.
    pre: code.language-javascript.
      Module.create('name', 'Title', 1, { 
          folder: 'my_folder_name' 
      });
    p If no settings is provided; the folder name is assumed to be the same as the module name.
    p This method returns an instance of the #[span.bold Module] class.

    p.bold addMenuItems(items)
    ul: li
      tag items 
      | Menu object or array of menu objects. A menu object has the following format:
      pre: code.language-javascript.
        {
            text: "Title", // Text to show on the sidebar
            sref: "app.state.name", // Target state name prefixed by 'app.'
            icon: "icon-grid", // Icon of the menu item
            alert: "new" // Added a budge to the menu item
        }
    p This method returns the same calling Module instance so that we can chain calls to other methods.
  page
    p.bold addStates(states)
    ul: li
      tag states 
      | State object or array of state objects. A state object has the following format:
      pre: code.language-javascript.
        {
            name: 'test.state_one', // Required
            url: '/my-url', // If not provided,it will be defined
            // based on the name ('/state-one' for this example)
            title: 'Title', // If not provided,it will be defined
            // based on the name ('State One' for this example)
            templateUrl: 'view.html', // name of the view file 
            // with html extension instead of jade. If not provided 
            // the view name will be 'state-one.html' in this case.
            controller: 'MyController', // name of the controller 
            // handeling the state. If not provided, it will be 
            // 'TestStateOneController' for this case.
            resolve: ['test', 'chartjs'] // names of dependencies
            // on which this state depends. The name of its own
            // module should be part of the dependencies.
        }

    p This method returns the same calling Module instance so that we can chain calls to other methods.

    p.bold start()
    p This method should be called once all the desired menu items and states were added to the module. It executes the corresponding code on the AngularJS instance and integrate the module with the rest of the application.

    h3 Dependencies class
    p This class is named #[tag Deps] and it handles the list of dependencies which are loaded with modules on request. The Module class uses this one to know which files to load for each dependency name. The main methods of this class are:
    p.bold Deps.addLibraries(items), Desps.addAngularModules(items) and Deps.addModules(items)
    p These methods are used to add dependencies. The #[tag items] arguments in a dependency or a list of dependencies. A dependency has the following structure:
  page
    pre: code.language-javascript.
      {
        name: "The dependency name",
        files: [
          "my-dependency.css",
          "my-dependency.js"
        ]
      }
    p.bold Deps.get(name)
    p This method gets the list of files of a module based on the name. If no module with the given name is found, the method returns #[tag null].  
    
    h3 Colors class
    p This class makes it simple to request colors and use them to draw charts without having to write the HEX or RGB code of colors. It also gives the possibility to make a color darker or lighter by a percentage. Its main methods are:
    p
      span.bold Colors.add(name, hex)
      | : add a color with the specifique name and HEX code.
    p
      span.bold Colors.get(name [, percentage])
      | : gets the hex code of the color. A percentage can optionaly be applied on the color. I the percentage < 1 the color becomes darker; else it becomes lighter.
    p
      span.bold Colors.lighten(hex [, percentage])
      | : make a color lighter based on a percentage. The percentage is 0.25 by default.
    p
      span.bold Colors.darken(hex [, percentage])
      | : make a color darker based on a percentage. The percentage is 0.25 by default.

    h2 Step by step example: the Trends analysis module
    p In this part I will explain how the Trends analysis modules (one of the modules I created for the frontend application) was made step by step.
    h3 Use Cases
    p The first step is to define the features or use cases of our module. The use cases for the Trends module are the following:
    ul
     li User should select an application and possibly multiple options and versions.
     li On every change of the selection; We have to retrieve all the job results of jobs from the selected application, options and version. Then a table should show the list of attributes found on these results.
     li User should be able to filter attributes by name.
  page
    ul
     li User should be able to show the Trends plot (showing the mean and deviation by version) of any attribute by clicking on the corresponding button.
     li If a plot is shown and the user copied the link. Visiting that link again should re-produce the plot with the same selected application, options and version for the same attribute.
    h3 Files structure
    p This module will have only one state, so one view and one controller; the files structure can be like this:
    +code('bash', 'Trends analysis module files structure').
      master
          |-- modules
              |-- demo/
                  |-- js/
                  |   |-- controllers/
                  |         |-- demo.js
                  |   |-- init.js
                  |-- less/
                  |     |-- style.less
                  |-- views/
                        |-- demo.jade
    h3 Module declaration
    p The module declaration is written on the file #[tag js/init.js]:
    pre: code.language-javascript.
      Module.create('demo', 'Demo', 2)
        .addMenuItems({
          text: "Demo",
          sref: "app.demo",
          icon: "icon-grid"
        })
        .addState({
          name: 'demo',
          resolve: ['demo', 'chartjs', 'ngTable', 'ngDialog']
        })
        .start();
  page
    p According to the previous code, we are creating a module named demo having one menu item pointing to the #[tag app.demo] state. The only state of the module is named demo. Note that the menu item is pointing to #[tag app.demo] while the state's name is just demo. That's fine because the Module class prefixes all state names with "app.". This module depends on:
    ul
      li 
        span.bold chartjs: 
        | used to draw plots
      li 
        span.bold ngTable: 
        | used to show the attributes table
      li 
        span.bold ngDialog: 
        | used to create the popup showing the plot.
    h3 Adding Search Form
    p Now let's write this code on the view to show the search form:
    pre: code.language-jade.
      h3 Trends
        small.text-muted Attributes values by version
      .row.traditional(ng-class="csspinner")
        .col-lg-4
          search-jobs(on-found="requestStatistics(searchParams)")
        .col-lg-8
          p The attributes table will be added here !
    p As you see, we have told the #[tag search-jobs] directive to call the function #[tag requestStatistics()] on every change; So we have to define this function in the controller. So for the moment the controller's code will be like this:
    pre: code.language-javascript.
      App.controller('DemoController', ['$scope', function($scope) {
          $scope.appId = undefined;
          $scope.options = undefined;
          $scope.versions = undefined;

          $scope.requestStatistics = function(params) {
              $scope.appId = params.apps[0];
              $scope.options = params.options;
              $scope.versions = params.versions;
          };
      }]);
    p On every change, we are saving the selected parameters in the variables $scope.appId, $scope.options and $scope.versions.
  page
    h3 Showing Attributes on a table
    p Let's add the attributes table to our view; the code will become like this:
    pre: code.language-jade.
      h3 Trends
        small.text-muted Attributes values by version
      .row.traditional(ng-class="csspinner")
        .col-lg-4
          search-jobs(on-found="requestStatistics(searchParams)")
        .col-lg-8
          table.table.table-striped.table-bordered.table-hover.be-responsive(ng-table="attrsTableParams")
            thead
              th ID
              th Name
              th 
            tbody
              tr(ng-repeat="a in $data")
                td {{a.id}}
                td {{a.name}}
                td
                  button.btn.btn-primary(ng-click="showChart(a)") Show
    p We applied the #[tag ng-table] directive to our table using #[tag attrsTableParams] variable which will be defined in the controller. Each row of the table shows the id of the attribute, its name and a button to show its corresponding plot. Note that we pass the attribute to the function #[tag showChart(a)] when the button is clicked using the #[tag ng-click] directive.
    p Now let's add the variable #[tag attrsTableParams] and the function #[tag showChart] to the controller. First of all, we need to inject the #[tag ngTableParams] and #[tag lhcbprResources] services into our controller to be able to use them; we do this by Adding them to controller parameters like this:
    pre: code.language-javascript.
      App.controller('DemoController', ['$scope', 'ngTableParams', 'lhcbprResources', 
        function($scope, $tableParams, $api) {
    p Note that we add the #[tag ngTableParams] and #[tag lhcbprResources] to the array and to the function arguments. The order of arguments should be the same as in the array. So here the argument #[tag $scope] is referencing the #[tag $scope] service, #[tag $tableParams] is referencing the #[tag ngTableParams] and #[tag $api] is referencing #[tag lhcbprResources].
  page
    p Now we can use #[tag $tableParams] to define #[tag attrsTableParams] like this:
    pre: code.language-javascript.
      $scope.attrsTableParams = new $tableParams(
          {
              page: 1, // the page to show initialy
              count: 10 // number of rows on each page
          }, 
          { 
              total: 0, // total number of rows initialy
              // function that fetchs data to fill the table
              getData: function($defer, params) {
                  // We check if an application and options were selected
                  if($scope.appId && $scope.options){
                      // We construct the data to send with the request to the API
                      var requestParams = {
                          app: $scope.appId,
                          options: $scope.options,
                          versions: $scope.versions,
                          page: params.page(),
                          page_size: params.count()
                      };
                      // TODO: The filter code will be added here
                      // We send the request to the '/trends' url of the API
                      $api.all('trends')
                          .getList(requestParams)
                          .then(function(trends){ // When we receive the response
                          // We set the total number of rows
                          if(trends._resultmeta){
                              params.total(trends._resultmeta.count);
                          }
                          // We fill the table with the response
                          $defer.resolve(trends);
                          // TODO: the code to show the plot based on the URL will be added here
                      });
                  }
              }
          }
      );
      // We add this line of code to fix a bug in the ngTable service
      $scope.attrsTableParams.settings().$scope = $scope;
  page
    p After this, we need a function which updates the table's content after every change of the selected application, options or versions.
    pre: code.language-javascript.
      $scope.update = function(){
          // Set the current page of the table to the first page
          $scope.attrsTableParams.page(1);
          // reloading data
          $scope.attrsTableParams.reload();
      }
    p Now we go back to the function #[tag requestStatistics] and call the function #[tag update] after every change:
    pre: code.language-javascript.
      $scope.requestStatistics = function(params) {
          $scope.appId = params.apps[0];
          $scope.options = params.options;
          $scope.versions = params.versions;
          $scope.update();
      };
    p Finally let's add the #[tag showChart] function:
    pre: code.language-javascript.
      $scope.showChart = function(a){
          console.log('Showing chart of ' + a.name);
      };
    p This function just prints the message "Showing chart of [attribute name]" on the console for the moment. We will add the Chart code below.
    h3 Filtering attributes by name
    p Now let's add a text input to filter attributes by name. We start by adding a form containing one input before the table on the view; the code of the view becomes as follows:
  page
    pre: code.language-jade.
      h3 Trends
        small.text-muted Attributes values by version
      .row.traditional(ng-class="csspinner")
        .col-lg-4
          search-jobs(on-found="requestStatistics(searchParams)")
        .col-lg-8
          form
            .form-group
              label Filter Attributes
              input.form-control(ng-model='attrFilter', ng-change='update()', type='text')
          table.table.table-striped.table-bordered.table-hover.be-responsive(ng-table="attrsTtableParams")
            thead
              th ID
              th Name
              th 
            tbody
              tr(ng-repeat="a in $data")
                td {{a.id}}
                td {{a.name}}
                td
                  button.btn.btn-primary(ng-click="showChart(a)") Show
    p Please note that in this line:
    pre: code.language-jade.
      input.form-control(ng-model='attrFilter', ng-change='update()', type='text')
    p We bind the value of the input to the scope variable named #[tag attrFilter] and we call #[tag update()] on every change.
    p Let's go to the controller and replace this comment on the #[tag getData] function:
    pre: code.language-javascript.
      // TODO: The filter code will be added here
    p With this piece of code:
    pre: code.language-jade.
      // remove additional spaces from the input value
      $scope.attrFilter = $scope.attrFilter.trim();
      // if the value is not empty; we add it to the request parameters
      if($scope.attrFilter && $scope.attrFilter != '')
          requestParams.attr_filter = $scope.attrFilter;
  page
    h3 Showing the Chart
    p Till now, when we click the "Show" button to show the chart; nothing happens. Let's fix this.
    p The plot will be shown into a ngDialog (which is a popup). So we have to define the content of this popup. One of the simple way to do it is to include it in the view as an inline template by adding this code at the end of the view code:
    pre: code.language-jade.
      script(type="text/ng-template", id="chartTemplate")
        .row
          .col-lg-10.col-lg-offset-1.col-md-10.col-md-offset-1.col-sx-10.col-sx-offset-1
            h2 {{name}}
            .chart
              canvas(linechart='', options='lineOptions', data='lineData', height='chartHeight()', width='chartWidth()')
    p In this code, we defined an inline template with the name "chartTemplate". The plot will be shown into the canvas element because we applied the directive linechart to it. This directive needs two properties options and data which we filled with the scope variables #[tag lineOptions] and #[tag lineData]; We will define these variables in the controller. We have also specified the width and height of the chart using the scope functions chartWidth and chartHeight that will be defined on the controller too.
    p Now we move to the controller and add the following code:
    pre: code.language-javascript.
      $scope.lineOptions = {
          animation: false,
          errorDir : "both",
          errorStrokeWidth : 3,
          datasetFill : false,
          scaleOverride : true,
          scaleSteps : 10,
          scaleStepWidth : 1,
          scaleStartValue : 0,
              tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %><%if (errorBar){%> ± <%=errorBar.errorVal%><%}%>",
          legendTemplate : '<% for (var i=0; i<datasets.length; i++){%><span class="label label-default" style="background-color:<%=datasets[i].fillColor%>"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span> <%}%>'
      };
      $scope.chartHeight = function() {
          return $(window).height() - 140;
      };
      $scope.chartWidth = function() {
          return $(window).width() - 60;
      };
  page
    p Then we write the code of the showChart function:
    pre: code.language-javascript.
      $scope.showChart = function(a){
          console.log('Show chart of ' + a.name);
          // We store versions, averages and deviations in separated tables
          // with the same order and we compute the min and max values
          var minValue = a.values[0].average - a.values[0].deviation, 
              maxValue = a.values[0].average + a.values[0].deviation,
              value = 0,
              versions = [],
              averages = [],
              deviations = [];
          a.values.forEach(function(v){
              v.average = parseInt(100 * v.average) / 100.0;
              v.deviation = parseInt(100 * v.deviation) / 100.0;
              averages.push(v.average);
              versions.push(v.version);
              deviations.push(v.deviation);
              value = v.average - v.deviation;
              if(value < minValue)
                  minValue = value;
              value = v.average + v.deviation;
              if(value > maxValue)
                  maxValue = value;
          });
          minValue = Math.floor(minValue);
          maxValue = Math.floor(maxValue) + 1;
          // We configure the chart to show only values between minValue and maxValue
          $scope.lineOptions.scaleStartValue = minValue;
          $scope.lineOptions.scaleSteps = maxValue - minValue;
          $scope.lineOptions.scaleStepWidth = 1;
          while ( $scope.lineOptions.scaleSteps > 25 ){
              $scope.lineOptions.scaleSteps /= 2;
              $scope.lineOptions.scaleStepWidth *= 2;
          }
  page
    pre: code.language-javascript.
      // ...
          // We set the data to show on the chart
          $scope.lineData = {
              labels: versions,
              datasets: [{
                  label: a.name,
                  fillColor : "rgba(220,220,220,0.2)",
                  strokeColor : "#2F49B1",
                  pointColor : "#5E87D6",
                  pointStrokeColor : "#fff",
                  pointHighlightFill : "#fff",
                  pointHighlightStroke : "#5E87D6",
                  data: averages,
                  error: deviations
              }]
          };
          // We set the name of the attribute
          $scope.name = a.name;
          // We show the popup
          $dialog.open({
              template: 'chartTemplate',
              className: 'chart-dialog',
              scope: $scope
          });
      }

    h3 Binding selected values to the URL
    p When we show the chart, we need to add the id of the shown attribute to the URL, and when the popup is closed we just remove this information from the URL. To do this, we need the #[tag $location] service that we will inject into our controller:
    pre: code.language-javascript.
      App.controller('DemoController', ['$scope', 'ngTableParams', 'lhcbprResources', '$location', function($scope, $tableParams, $api, $location) {
    p Then we change the last part of showChart function:
  page
    pre: code.language-javascript.
      $scope.showChart = function(a){
          // ... code here remains the same
          // We show the popup
          $dialog.open({
              template: 'chartTemplate',
              className: 'chart-dialog',
              scope: $scope,
              preCloseCallback: function() { // When the popup is closed
                  $scope.$apply(function(){
                      // We remove the attr from the URL
                      $location.search('attr', null);
                  });
              }
          });
          // After showing the popup we set the attr on the URL
          $location.search('attr', a.id);
      }
    p The last step is to check if the attr is set on the URL when the user first visits the page and if set show the chart directly. We will have to do this check after loading the data from the API. So we go back to the getData function of the $scope.attrsTableParams and we replace the comment:
    pre: code.language-javascript.
      // TODO: the code to show the plot based on the URL will be added here
    p With the following code:
    pre: code.language-javascript.
      // Read the attribute id from the URL
      var paramsAttr = $location.search().attr;
      // if found
      if(paramsAttr !== undefined){
          // Search the corresponding attribute on the response
          var a = undefined;
          trends.forEach(function(t){
              if(t.id == paramsAttr) a = t;
          });
          // If the corresponding attribute found
          if(a !== undefined){ // Show the chart
              $scope.showChart(a);
          }
      }
  page
    h1.no-number Conclusion
    p My final internship at CERN is the best job experience I had till now. During this period, I discovered new cultures by meeting people from different countries, I worked within a group in a new flexible way and I learned new web development technologies.
    p This internship was part of my third year studies at ISIMA. I worked as a software engenieer to develop and improve the LHCbPR (LCHb Performance and Regression) application. The applications used to analyse data collected by the detector on LHCb are tested using configurable test jobs. The main goal of LHCbPR is to provide physicists and developers with a framework in which they can easily do analysis of test jobs results. We started the development of the second version of this application from scratch and used flexible architecture and recent technologies. This version contains three layers: A database, a REST API and a frentend web application. My task was mainly to develop the frontend application and the analysis modules using AngularJS and new web development tools. But I did also some changes in the backend which was built using Django REST framework (written with Python programming language).
    p I started the application based on a template containing AngularJS and other libraries. After understanding the structure of the template I started customizing it to fit our needs. Modifications have been done on the files structure, the build system and the javascript code. The next step was to create some analysis modules and to add new helper classes which simplify this process. Finally I have written a development guide for users explaining how to add new analysis modules to the application.
    p The first version of the frontend application was done with three analysis modules. Other analysis modules should be added to have to same functionalities as the old version. One perspective was to simplify adding module for persons with no AngularJS knowledge by giving an easy to use group of functions hiding the complexity of this framework. This simplification layer could be made in a generic way giving the possibility to use it to build other modular web applications.
